<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <link>http://midhunkrishna.in/index.xml</link>
    <description>Recent content on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 14 Aug 2017 15:31:25 +0530</lastBuildDate>
    <atom:link href="http://midhunkrishna.in/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ctes and window functions</title>
      <link>http://midhunkrishna.in/posts/2017/08/ctes-and-window-functions/</link>
      <pubDate>Mon, 14 Aug 2017 15:31:25 +0530</pubDate>
      
      <guid>http://midhunkrishna.in/posts/2017/08/ctes-and-window-functions/</guid>
      <description>

&lt;p&gt;I am a big fan of code readability, but being a fan and expecting the code I write to be readable are two different things. Readable code is easier to understand and much more straightforward to grasp. One significant difference I find while comparing readable and unreadable code, apart from the obvious, is how many different variables I have to hold in my head at a time while I try to grapple my head around it. If this task is simple, I believe that this is not because of some random act of brilliance but due to careful code construction.&lt;/p&gt;

&lt;p&gt;A particular example is SQL. The more it does, the more it gets unreadable, A good way to make it readable is using the above mentioned Common Table Expressions or CTEs.&lt;/p&gt;

&lt;p&gt;CTEs helps achieve this by its ability to separate data into independent logical entities according to the context of the query.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/midhunkrishna/6c863c9b7125e89409395556c70ce790.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Hence we have a clear classification called popular posts, which is an abstraction of any post with an upvote count of six or above.&lt;/p&gt;

&lt;h2 id=&#34;what-i-came-across-the-other-day&#34;&gt;What I came across the other day&amp;hellip;&lt;/h2&gt;

&lt;p&gt;The other day I ran into a case in which a query was taking much more time than it should. When checked, I found that the join table was quite large. I didn&amp;rsquo;t know how to handle this but hey, someone must have faced a similar issue and then I found out window functions.&lt;/p&gt;

&lt;p&gt;Lets take a use case and see how Window Functions can be of use.&lt;/p&gt;

&lt;p&gt;For a particular report, in our e-commerce app, we need to find out each item&amp;rsquo;s latest n review-comments, in our case, we can set n = 2.&lt;/p&gt;

&lt;p&gt;We can write a simple join and then filter that in our application language (Ruby, Go, PHP etc.)&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/midhunkrishna/9c1336862b3946b305ddeea530fc03f2.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;but, for a system like Amazon, this solution would turn out to be awful since items might have large number of comments and to tackle the sheer number of items an comments, we will have to possibly reduce the dataset size even before the join.&lt;/p&gt;

&lt;h2 id=&#34;window-function&#34;&gt;Window Function&lt;/h2&gt;

&lt;p&gt;In general, a Window Function, is a mathematical function that is zero valued outside of some interval. In case of SQL engines, they operate on rows that are related to the current row, in our case, this can be the item_id. All rows of the join that has a common item_id acts as a partition over which the window function acts.&lt;/p&gt;

&lt;h2 id=&#34;getting-back-to-our-problem&#34;&gt;Getting back to our problem&lt;/h2&gt;

&lt;p&gt;We rewrite our query to do the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Window function should operate on a partition of same item_ids&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Each of these partitions should be ordered by created time stamp of review_comment&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;select only the top two from each partition&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;script src=&#34;//gist.github.com/midhunkrishna/bdd4e9a25e522e90c1fa93ee1bc39a78.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This still is resulting in full join table, but now we have &lt;code&gt;comment_row_number&lt;/code&gt; field to let us know that the newest review_comment has a value of 1. All we need to do now is to filter using that column. We have used row_number() function from postgres as the window function here. &lt;a href=&#34;https://www.postgresql.org/docs/9.3/static/functions-window.html&#34;&gt;According to the docs, &lt;/a&gt;
 any built-in or user-defined aggregate function can be used as a window function.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/midhunkrishna/132a8c3bc1b3e380d90be2ca0b262c2e.js&#34;&gt;&lt;/script&gt;

&lt;h2 id=&#34;putting-it-all-together&#34;&gt;Putting it all together&lt;/h2&gt;

&lt;p&gt;Even though we have our answer, our query has become pretty hard to read. We can get better readability by introducing a &lt;a href=&#34;https://www.postgresql.org/docs/9.6/static/queries-with.html&#34;&gt;Common Table Expression. &lt;/a&gt;
&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/midhunkrishna/685717a9a21cf066d60d1e473096e675.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Well, that is it folks. We have put together two concepts, readbility and performance to create something which is the best of both worlds.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>